<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: webElement.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: webElement.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>'use strict';

var utils = require('./utils'),
	errors = require('./errors');


/**
 * Element constructor
 * @class WebElement
 * @param {String} id Element id (e.g. returned by {@link WebDriver#get})
 * @param {WebDriver} driver
 */
function WebElement(id, driver) {
	//TODO: remove `this.ELEMENT` if it is not required
	this.id = this.ELEMENT = id;
	this.driver = driver;
	this.logMethodCalls = this.driver.logMethodCalls;
};

function returnSelf(callback, self) {
	return function(err) {
		callback(err, self);
	};
}

// returns index of first function from `args`
function indexOfFunctionInArgs(args) {
	var index = 0;
	while (index &lt; args.length && !utils.isFunction(args[index])) index++;
	return utils.isFunction(args[index]) ? index : -1;
}

// replace first function from `args` on `returnSelf`
function repalceArgsCallbackOnReturnSelf(args, self) {
	var index = indexOfFunctionInArgs(args);
	if (index !== -1) args[index] = returnSelf(args[index], self);
	return args;
}

/**
 * Send a sequence of key strokes to an element.
 * @param {String} value
 * @param {Function} callback(err:Error,element:WebElement)
 */
WebElement.prototype.sendKeys = function(value, callback) {
	//TODO: remove `clear`
	if (value) {
		this.driver._cmd({
			path: '/element/' + this.id + '/value',
			method: 'POST',
			data: {value: utils.replaceKeyStrokesWithCodes(value).split('')}
		}, returnSelf(callback, this));
	} else {
		this.clear(callback);
	}
};

/**
 * Clear a TEXTAREA or text INPUT element's value.
 * @param {Function} callback(err:Error,element:WebElement)
 */
WebElement.prototype.clear = function(callback) {
	this.driver._cmd({
		path: '/element/' + this.id + '/clear',
		method: 'POST'
	}, returnSelf(callback, this));
};

/**
 * Get value of current element (alias to getAttr('value')).
 * @param {Function} callback(err:Error,value:String)
 */
WebElement.prototype.getValue = function(callback) {
	this.getAttr('value', callback);
};

/**
 * Get the value of an element's attribute.
 * @param {String} name Attribute's name
 * @param {Function} callback(err:Error,value:String)
 */
WebElement.prototype.getAttr = function(name, callback) {
	this.driver._cmd({
		path: '/element/' + this.id + '/attribute/' + name,
		method: 'GET'
	}, callback);
};

/**
 * Get the visible text of the element.
 * @param {Function} callback(err:Error,text:String)
 */
WebElement.prototype.getText = function(callback) {
	this.driver._cmd({
		path: '/element/' + this.id + '/text',
		method: 'GET'
	}, callback);
};

/**
 * Get element's tag name.
 * @param {Function} callback(err:Error,tagName:String)
 */
WebElement.prototype.getTagName = function(callback) {
	this.driver._cmd({
		path: '/element/' + this.id + '/name',
		method: 'GET'
	}, callback);
};

/**
 * Click on an element.
 * @param {Function} callback(err:Error,element:WebElement)
 */
WebElement.prototype.click = function(callback) {
	this.driver._cmd({
		path: '/element/' + this.id + '/click',
		method: 'POST'
	}, returnSelf(callback, this));
};

/**
 * Move the mouse by an offset of the current element.
 * If the element is not visible, it will be scrolled into view.
 * @param {Object} offset Object with x, y offsets (relative to the top-left 
 * corner of the element) keys. If offset is not set the mouse will be moved 
 * to the center of the element.
 * @param {Function} callback(err:Error,element:WebElement)
 */
WebElement.prototype.moveTo = function(offset, callback) {
	callback = utils.isFunction(offset) ? offset : callback;
	offset = !utils.isFunction(offset) ? offset : {};
	this.driver._cmd({
		path: '/moveto',
		method: 'POST',
		data: {
			element: this.id,
			xoffset: offset.x,
			yoffset: offset.y
		}
	}, returnSelf(callback, this));
};

/**
 * Move to the current element and down mouse button. 
 * `button` accepts same values as at {@link WebDriver#mouseDown}.
 * @param {String} [button]
 * @param {Function} callback(err:Error,driver:WebDriver)
 */
WebElement.prototype.mouseDown = function() {
	var self = this,
		args = repalceArgsCallbackOnReturnSelf(arguments, this);
	this.moveTo(function(err) {
		if (err) return callback(err);
		self.driver.mouseDown.apply(self.driver, args);
	});
};

/**
 * Move to the current element and up mouse button. 
 * `button` accepts same values as at {@link WebDriver#mouseDown}.
 * @param {String} [button]
 * @param {Function} callback(err:Error,driver:WebDriver)
 */
WebElement.prototype.mouseUp = function() {
	var self = this,
		args = repalceArgsCallbackOnReturnSelf(arguments, this);
	this.moveTo(function(err) {
		if (err) return callback(err);
		self.driver.mouseUp.apply(self.driver, args);
	});
};

/**
 * Find element inside current element.
 * `selector` and `params` could accept same values as at {@link WebDriver#get}.
 * @param {String} selector
 * @param {Object} [params]
 * @param {Function} callback(err:Error,element:WebElement)
 */
WebElement.prototype.get = function(selector, params, callback) {
	callback = utils.isFunction(params) ? params : callback;
	params = !utils.isFunction(params) ? params : {};
	params.parent = this;
	this.driver.get(selector, params, callback);
};

/**
 * Find elements inside current element.
 * `selector` and `params` could accept same values as at {@link WebDriver#get}.
 * @param {String} selector
 * @param {Object} [params]
 * @param {Function} callback(err:Error,element:WebElement[])
 */
WebElement.prototype.getList = function(selector, params, callback) {
	callback = utils.isFunction(params) ? params : callback;
	params = !utils.isFunction(params) ? params : {};
	params.parent = this;
	this.driver.getList(selector, params, callback);
};

/**
 * Determine if an element is currently displayed.
 * @param {Function} callback(err:Error,displayed:Boolean)
 */
WebElement.prototype.isDisplayed = function(callback) {
	this.driver._cmd({
		path: '/element/' + this.id + '/displayed',
		method: 'GET'
	}, callback);
};

/**
 * Determine if an element is currently enabled.
 * @param {Function} callback(err:Error,enabled:Boolean)
 */
WebElement.prototype.isEnabled = function(callback) {
	this.driver._cmd({
		path: '/element/' + this.id + '/enabled',
		method: 'GET'
	}, callback);
};

/**
 * Describe the identified element.
 * This command is reserved for future use; its return type is currently undefined.
 * @param {Function} callback(err:Error,description:String)
 */
WebElement.prototype.describe = function(callback) {
	this.driver._cmd({
		path: '/element/' + this.id,
		method: 'GET'
	}, callback);
};

/**
 * Get the value of an element's computed CSS property.
 * @param {String} propName The CSS property name, not the JavaScript property
 * name (e.g. background-color instead of backgroundColor).
 * @param {Function} callback(err:Error,value:String)
 */
WebElement.prototype.getCssProp = function(propName, callback) {
	this.driver._cmd({
		path: '/element/' + this.id + '/css/' + propName,
		method: 'GET'
	}, callback);
};

var isVisibleInjection = utils.getInjectionSource(function() {
	function ___nwdIsVisible(element) {
		if (!element) return false;
		return (
			element.style.display !== 'none'
				? (element.offsetWidth > 0 || element.offsetHeight > 0)
				: false
		);
	}
});

/**
 * Determine if an element is currently visible.
 * @param {Function} callback(err:Error,visible:Boolean)
 */
WebElement.prototype.isVisible = function(callback) {;
	var self = this;
	function execute(withFunc) {
		self.driver.execute(
			(withFunc ? isVisibleInjection : '') + utils.getInjectionSource(function() {
				if (typeof window.___nwdIsVisible !== 'function') {
					if (typeof ___nwdIsVisible !== 'function') return 'needFunc';
					window.___nwdIsVisible = ___nwdIsVisible;
				}
				return ___nwdIsVisible(arguments[0]);
			}),
			[{ELEMENT: self.id}],
			false,
			function(err, result) {
				if (err) return callback(err);
				result === 'needFunc' ? execute(true) : callback(null, result);
			}
		);
	}
	execute();
};

/**
 * Wait for element disappear from the page.
 * @param {Function} callback(err:Error,driver:WebDriver)
 */
WebElement.prototype.waitForDisappear = function(callback) {
	var self = this;
	self.driver.waitFor(
		function(waitCallback) {
			self.isVisible(function(err, isVisible) {
				// Stale error is ok because it will occur when element is removed
				if (err && err instanceof errors.StaleElementReferenceError === false) {
					return callback(err);
				}
				waitCallback(!isVisible);
			});
		}, {
			errorMessage: 'waiting for element ' + self.id + ' disappear',
			timeout: self.driver.timeouts.waitForElementDisappear
		},
		callback
	);
};

/**
 * Wait untill element will be detached from page.
 * @param {Function} callback(err:Error,driver:WebDriver)
 */
WebElement.prototype.waitForDetach = function(callback) {
	var self = this;
	self.driver.waitFor(
		function(waitCallback) {
			self.getTagName(function(err) {
				waitCallback(err instanceof errors.StaleElementReferenceError);
			});
		}, {
			errorMessage: 'waiting for element ' + self.id + ' detach',
			timeout: self.driver.timeouts.waitForDetach
		},
		function(err) {
			callback(err, self);
		}
	);
};

utils.loggify(WebElement.prototype, 'WebElement');

exports.WebElement = WebElement;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="WebDriver.html">WebDriver</a></li><li><a href="WebElement.html">WebElement</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.2</a> on Tue Jun 17 2014 17:56:22 GMT+0400 (MSK)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
